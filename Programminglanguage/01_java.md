## Javaの主要概念（超特急）

#### オブジェクト
インスタンス変数の集まりからなるデータとそのデータに対する操作（メソッド）の集まり

#### インスタンス変数
オブジェクトに格納されるデータを表すための変数


#### メソッド
オブジェクト内のデータに対する操作<br>
メソッドが呼び出されると呼び出し元から与えられる引数とインスタンス変数を用いて計算する<br>
場合によってはインスタンス変数の値を代入によって更新<br>
最終的に何らかの計算結果を呼び出し元に返すことが多い<br>


#### シグネチャ
メソッドの名前、引数の個数とそれぞれの型、返り値をまとめた総称<br>
シグネチャさえわかればそのメソッドをどういう形式で呼び出せばいいかわかる

#### クラス
オブジェクトの定義を与えるプログラム構成要素<br>
- インスタンス変数の宣言
- インスタンス変数の初期化処理を記述するコンストラクタ
- メソッド定義
が含まれる


#### インターフェース
メソッドシグネチャをいくつか集めたものに名前をつけたもの<br>
同一シグネチャのメソッドを持つ（異なる）クラスのオブジェクトをまとめて扱う時に便利

1. オブジェクトに共通するメソッドのシグネチャを列挙したようなインターフェースⅠを定義する
2. 各クラスは、そのインターフェースを実装するという宣言( implements Ⅰ ) をつけて定義する（そのクラスにはインターフェースに書かれたシグネチャを持つメソッドを定義する義務が生じる）

Ⅰ型の変数にはⅠを実装したクラスのオブジェクトをどれでも格納することができ、その変数を通じてⅠで宣言されているメソッドを呼ぶことができる。
この際、実際に呼ばれるメソッド定義はその時に変数に格納されているオブジェクトのクラスに依存する（**動的ディスパッチ(dynamic dispatch)**）

## Javaプログラムの基本要素

Java プログラムは，実際にはコンパイラによってJava仮想機械の命令に変換され，それがJava 仮想機械によって実行されるわけだが，Java仮想機械を持ち出すことなく，Java プログラムの実行過程を理解する・説明できるようになることは，非常に大事である．
 コメント

同様に，何のプログラミング言語であっても，その実行過程を，実装方式や実行する計算機のハードウェアに依存しない抽象的なレベルで理解する・説明できるようになるのが望ましい．


#### 変数・オブジェクト・参照

変数：データを格納するためのメモリ領域

変数の働きを理解するためには、
- 変数をどのように宣言するのか？
- 宣言された変数は、プログラム文面のどの範囲で使用できるか？（これを変数の**有効範囲(scope)**という）
- 変数には何を格納するか？
- 変数に対してはどのような操作が許されるか？
- 変数に対応するメモリ領域はいつ・どのように確保され、その内容が初期化されるのか？


一つの言語には何種類もの○○変数が存在し、Javaには代表的な変数としてインスタンス変数、局所変数、クラス変数(static変数)がある

###### 各種変数の共通事項

- 変数は全て、その型を指定して宣言する
```
int x = 100;
```
```
BinarySearchTree insert(BinarySearchTree t1, int i) {...}
```

- 変数が格納するものに以下がある
    - 数値(整数(`int`)、倍精度浮動小数点数(`double`)など)
    - オブジェクトへの**参照(reference)**
    
    オブジェクトそのものは（メモリに領域が割り当てられるが）変数には直接格納されない（パラメータや返り値を通じてやり取りされるのもあくまでオブジェクトへの参照）

- 変数に対して行われる操作に以下が考えられる
    - 格納されている値の*読み出し*
    - 新しい値の*書き込み*


###### インスタンス変数
- クラス本体内でメソッド・コンストラクタと並んで宣言される
- 有効範囲はそのクラス内
- `new`式によってオブジェクトが生成されると、インスタンス変数のための領域が**ヒープ(heap)** と呼ばれるメモリ領域中に確保され、初期化子やコンストラクタでその内容の初期化が行われる。ヒープはプログラム実行中に新たに必要となる（＝プログラム実行開始時には確保されていない）メモリ領域を提供する仕組みである。多くのプログラミング言語ではヒープ以外にも実行時スタックと呼ばれる領域も使ってプログラムの実行が進む。
- そのオブジェクトが使われなくなると、**garbage collection** と呼ばれるプログラム実行系内の仕組みによってその領域は解放される


> インスタンス変数は多くの場合 private という 修飾子(modifier) を伴って宣言するが，後述のように，この修飾子そのものは，変数がインスタンス変数であることを**意味しない** ．インスタンス変数と局所変数を区別するのはその宣言の場所である．

###### 局所変数（メソッドのパラメータを含む）

- メソッドのヘッダ、`for`文、文の並びの途中で宣言される (`private`などのアクセス修飾子はつけてはいけない)
- メソッドパラメータと`for`文の場合、その直後のメソッド本体/ブロック`{...}`が有効範囲、文の並びの途中の宣言はその直後からブロック終了までが有効範囲となる
- メソッド呼び出しや`for` 文の実行などをきっかけとしてメモリ領域が確保され、ブロックの終了とともに領域が解放される


###### クラス変数
- クラス本体内でメソッド・コンストラクタと並んで宣言される（インスタンス変数と区別するため`static`修飾子が必要）
- 有効範囲はそのクラス
- プログラム実行開始とともに領域が確保され、初期化子によって内容が初期化される



#### オブジェクト生成

Javaのオブジェクト：クラス名とインスタンス変数の値の集合<br>
`new <クラス名>(<式1>,...,<式n>)`という式文でオブジェクトを生成する<br>
オブジェクト生成式の評価の過程
1. `<式1>`,...`,<式n>`を評価する（それらの値を$v_1,...,v_n$とする）
2. 指定されたクラス名とそのクラスのインスタンス変数用の領域が確保されて（未初期化の）オブジェクトが作らレル。そのオブジェクトにすでにあるオブジェクトとは異なるIDが割り振られる
3. コンストラクタのパラメータのための領域が確保され、$v_1,...,v_n$で初期化される。このとき、（代入不可能な）特別な変数`this`の領域も確保され、オブジェクトのIDが格納される
4. コンストラクタ本体が実行される。実行終了とともにパラメータと`this`のための領域は解放される
5. オブジェクトIDが`new`式全体の値となる


#### メソッド呼び出し

メソッド呼び出し式は一般に
```
<式0>.<メソッド名>(<式1>,...,<式n>)
```
という形をしている

メソッド呼び出し式の評価<br>
1. `<式0>`,...`,<式n>`を順に評価する（それらの値を$v_0,...,v_n$とする）
2. パラメータのための領域が新たに確保され、$v_1,...,v_n$で初期化される。このとき、特別な（代入不可能な）変数`this`も確保され、$v_0$が格納される
3. $v_0$は、あるオブジェクトへの参照である（ハズ）なので、参照されているオブジェクトのクラスに定義されている`<メソッド名>`という名前のメソッドを選び、その本体を実行する。実行終了とともにパラメータと`this`のための領域は解放される
4. `return`された値が式全体の値となる


動的ディスパッチの本質は呼び出すメソッドを選ぶステップにある
```
public interface BinaySearchTree {
    void insert(int n);
}

public class Leaf implements {
    ...
}

public class Branch implements {
    ...
}

```
のような定義がされているとき、`BinarySearchTree`型の変数は`Leaf`や`branch`クラスから作られたオブジェクトを格納している可能性がある。この場合、同じメソッド呼び出し式でも$v_0$が参照するオブジェクトのクラスによって違うメソッドが呼び出される

```
BinarySearchTree bst = new Branch(...);
bst.insert(5);
```
であれば、`Branch`中の`insert`が呼ばれる。
一般には変数にどちらのクラスのオブジェクトが格納されているかはわからないので、実行しながら決めることになる。


#### 変数とフレーム

**フレーム**<br>
メソッドやコンストラクタの実行の際に確保されるパラメータ変数のための領域。